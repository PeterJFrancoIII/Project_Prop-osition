"""
BaseStrategy â€” abstract strategy framework for all trading algorithms.

Every strategy inherits from BaseStrategy and implements:
  - generate_signal(): analyze data and return a buy/sell/hold signal
  - calculate_position_size(): determine order quantity
  - check_exit(): evaluate whether to close an existing position

Per SCALABLE_BUILD_PLAN.md Layer 2: standard interface, auto-logging,
performance tracking (Sharpe ratio, win rate, max drawdown).
"""

import logging
from abc import ABC, abstractmethod
from datetime import datetime
from decimal import Decimal
from typing import Optional

from apps.market_data.models import OHLCVBar

logger = logging.getLogger(__name__)


class Signal:
    """Represents a trading signal generated by a strategy."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"

    def __init__(
        self,
        action: str,
        ticker: str,
        quantity: Decimal = Decimal("0"),
        price: Decimal = Decimal("0"),
        confidence: float = 0.0,
        reason: str = "",
        strategy_name: str = "",
        sentiment_score: Optional[float] = None,
    ):
        self.action = action
        self.ticker = ticker
        self.quantity = quantity
        self.price = price
        self.confidence = confidence
        self.reason = reason
        self.strategy_name = strategy_name
        self.sentiment_score = sentiment_score
        self.timestamp = datetime.now()

    @property
    def is_actionable(self) -> bool:
        """True if this signal should trigger a trade (not HOLD)."""
        return self.action in (self.BUY, self.SELL)

    def to_dict(self) -> dict:
        """Convert to executor-compatible signal dict."""
        return {
            "ticker": self.ticker,
            "action": self.action,
            "quantity": str(self.quantity),
            "price": str(self.price),
            "strategy": self.strategy_name,
            "confidence": self.confidence,
            "reason": self.reason,
            "sentiment_score": self.sentiment_score,
            "timestamp": self.timestamp.isoformat(),
        }

    def __repr__(self):
        return f"Signal({self.action} {self.quantity} {self.ticker} @ {self.price} | {self.reason})"


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Subclasses must implement:
      - generate_signal(ticker, bars) -> Signal
      - calculate_position_size(ticker, price, account_equity) -> Decimal
      - check_exit(ticker, entry_price, current_price, bars) -> Signal

    The strategy runner calls these methods for each active strategy.
    """

    name: str = "unnamed_strategy"
    version: str = "0.1.0"
    asset_class: str = "stocks"
    timeframe: str = "1d"
    description: str = ""

    def __init__(self, config: dict = None):
        """
        Initialize with optional config dict.

        Args:
            config: Strategy-specific parameters (from Strategy.custom_params).
        """
        self.config = config or {}

    @abstractmethod
    def generate_signal(self, ticker: str, bars: list) -> Signal:
        """
        Analyze market data and return a trading signal.

        Args:
            ticker: Stock symbol (e.g., "AAPL").
            bars: List of OHLCVBar-like dicts with keys:
                  open, high, low, close, volume, timestamp.

        Returns:
            Signal object (BUY, SELL, or HOLD).
        """
        pass

    @abstractmethod
    def calculate_position_size(
        self, ticker: str, price: Decimal, account_equity: Decimal
    ) -> Decimal:
        """
        Calculate the number of shares to buy/sell.

        Args:
            ticker: Stock symbol.
            price: Current/signal price.
            account_equity: Available account equity.

        Returns:
            Number of shares (Decimal).
        """
        pass

    @abstractmethod
    def check_exit(
        self, ticker: str, entry_price: Decimal, current_price: Decimal, bars: list
    ) -> Signal:
        """
        Check if an existing position should be closed.

        Args:
            ticker: Stock symbol.
            entry_price: Position entry price.
            current_price: Current market price.
            bars: Recent OHLCV data.

        Returns:
            Signal.SELL if should exit, Signal.HOLD if should keep.
        """
        pass

    def get_bars(self, ticker: str, timeframe: str = None, limit: int = 100) -> list:
        """
        Fetch OHLCV bars from the database.

        Returns list of dicts for easy indicator calculation.
        """
        tf = timeframe or self.timeframe
        bars = OHLCVBar.objects.filter(
            symbol=ticker, timeframe=tf
        ).order_by("-timestamp")[:limit]

        return [
            {
                "open": float(bar.open),
                "high": float(bar.high),
                "low": float(bar.low),
                "close": float(bar.close),
                "volume": bar.volume,
                "timestamp": bar.timestamp,
            }
            for bar in reversed(bars)  # Oldest first
        ]

    def get_market_sentiment(self, ticker: str, date_cutoff: Optional[datetime] = None, days_back: int = 7) -> dict:
        """
        Calculates aggregate sentiment for a ticker (or general market) over the last X days based on News.
        Returns {"score": float, "count": int}.
        """
        try:
            from django.utils import timezone
            from datetime import timedelta
            from apps.market_data.models import NewsArticle
            
            cutoff = date_cutoff or timezone.now()
            start_time = cutoff - timedelta(days=days_back)
            
            # Fetch general market news or specific ticker news
            articles = NewsArticle.objects.filter(
                published_at__gte=start_time,
                published_at__lte=cutoff
            )
            
            if not articles.exists():
                return {"score": 0.0, "count": 0}
                
            total_score = sum(float(a.sentiment_score) for a in articles)
            return {
                "score": total_score / articles.count(),
                "count": articles.count()
            }
        except Exception as e:
            logger.error(f"Error fetching news sentiment: {e}")
            return {"score": 0.0, "count": 0}

    def get_social_sentiment(self, ticker: str) -> dict:
        """
        Calculates aggregate retail sentiment for a ticker using SocialScraper.
        """
        try:
            from apps.ai_brain.social_scraper import SocialScraper
            from apps.ai_brain.sentiment import SentimentAnalyzer
            
            scraper = SocialScraper()
            analyzer = SentimentAnalyzer()
            
            texts = scraper.get_aggregate_social_texts(ticker)
            if not texts:
                return {"score": 0.0, "count": 0}
                
            total_score = 0.0
            for text in texts:
                result = analyzer.analyze(text)
                total_score += result["score"]
                
            return {
                "score": total_score / len(texts),
                "count": len(texts)
            }
        except Exception as e:
            logger.error(f"Error fetching social sentiment: {e}")
            return {"score": 0.0, "count": 0}

    def apply_ai_filters(self, signal: Signal, date_cutoff: Optional[datetime] = None) -> Signal:
        """
        Adjusts or blocks a signal based on AI market sentiment (News + Social).
        """
        if not signal.is_actionable:
            return signal
            
        # Optional kill-switch via config
        if not self.config.get("use_ai_sentiment", True):
            return signal
            
        sentiment_data = self.get_market_sentiment(signal.ticker, date_cutoff)
        score = sentiment_data["score"]
        
        # Merge social sentiment if not running historical backtest
        if not date_cutoff and self.config.get("use_social_sentiment", True):
            social_data = self.get_social_sentiment(signal.ticker)
            if social_data["count"] > 0:
                # Weighted average: 60% news, 40% retail social
                score = (score * 0.6) + (social_data["score"] * 0.4)
                sentiment_str = f" | AI Sentiment: {score:+.2f} ({sentiment_data['count']} news, {social_data['count']} social)"
            else:
                sentiment_str = f" | AI Sentiment: {score:+.2f} ({sentiment_data['count']} news)"
        else:
            sentiment_str = f" | AI Sentiment: {score:+.2f} ({sentiment_data['count']} articles)"
        
        signal.sentiment_score = score
        signal.reason += sentiment_str
        
        # Bear market / Panic filter: Block BUYs during extreme negative news/social cycles
        if score < -0.2 and signal.action == Signal.BUY:
            signal.reason += " -> BLOCKED by Negative AI Sentiment"
            signal.action = Signal.HOLD
            
        return signal

    def apply_fundamental_filters(self, signal: Signal) -> Signal:
        """
        Adjusts or blocks a signal based on fundamental data (valuation, earnings, analyst consensus).
        """
        if not signal.is_actionable or not self.config.get("use_fundamentals", True):
            return signal
            
        try:
            from apps.ai_brain.fundamentals import FundamentalAnalyzer
            analyzer = FundamentalAnalyzer()
            
            # Analyst consensus check
            consensus = analyzer.get_analyst_consensus(signal.ticker)
            score = consensus.get("score", 3.0)
            
            # Score is 1 (Strong Buy) to 5 (Sell). We block Buys if the score is > 3.0 (worse than Hold)
            if score > 3.0 and signal.action == Signal.BUY:
                signal.reason += f" -> BLOCKED by Analyst Consensus ({score:.1f})"
                signal.action = Signal.HOLD
                return signal
                
            # Valuation check
            val = analyzer.get_valuation_metrics(signal.ticker)
            fwd_pe = val.get("forward_pe", 0.0)
            
            if fwd_pe > 50.0 and signal.action == Signal.BUY:
                 # Very expensive valuation - warn but maybe don't strictly block unless configured
                 signal.reason += f" | NOTE: High Fwd P/E ({fwd_pe:.1f})"
                 
            # Earnings drift check
            earnings = analyzer.get_earnings_surprise(signal.ticker)
            drift = earnings.get("drift_signal", "neutral")
            
            if drift == "bearish" and signal.action == Signal.BUY:
                signal.reason += " -> BLOCKED by Negative Earnings Surprise"
                signal.action = Signal.HOLD
                return signal
                
        except Exception as e:
            logger.error(f"Error applying fundamental filters for {signal.ticker}: {e}")
            
        return signal

    def apply_regime_filters(self, signal: Signal, date_cutoff: Optional[datetime] = None) -> Signal:
        """
        Adjusts or blocks a signal based on broad market regime (SPY trend, volatility, crashes).
        """
        if not signal.is_actionable or not self.config.get("use_regime_filters", True):
            return signal
            
        try:
            from apps.ai_brain.regime import RegimeDetector
            detector = RegimeDetector()
            regime = detector.get_market_regime(date_cutoff, lookback_days=60)
            
            trend = regime.get("trend", "unknown")
            is_crash = regime.get("is_crash_mode", False)
            vol = regime.get("volatility", "neutral")
            
            # 1. Crash Protection: Block all BUYs if SPY is crashing
            if is_crash and signal.action == Signal.BUY:
                signal.reason += " -> BLOCKED by Market Crash Regime"
                signal.action = Signal.HOLD
                return signal
                
            # 2. Trend Alignment: If SPY is bearish, be very careful with momentum buys
            if trend == "bearish" and signal.action == Signal.BUY:
                # Option: Strict mode blocks all Buys in bear market.
                # For now, we will add a warning note, or we can optionally block.
                # Let's block it from Mean Reversion and Momentum since they fight the tape
                if getattr(self, "name", "").lower() in ["momentum breakout", "mean reversion"]:
                     if self.config.get("strict_trend_alignment", False):
                         signal.reason += f" -> BLOCKED by Bearish Market Trend ({trend})"
                         signal.action = Signal.HOLD
                         return signal
                     else:
                         signal.reason += f" | NOTE: Fighting Bearish Trend"
                         
        except Exception as e:
            logger.error(f"Error applying regime filters for {signal.ticker}: {e}")
            
        return signal

    def apply_kelly_sizing(self, signal: Signal, account_equity: Decimal, local_pnl_history: list[float] | None = None) -> Signal:
        """
        Calculates optimal position size using the Kelly Criterion based on strategy edge.
        If the strategy has a negative mathematical edge, trades can be scaled down to 0 (cash mode).
        Overrides signal.quantity.
        """
        use_kelly = self.config.get("use_kelly_sizing", False)
        if not use_kelly or not signal.is_actionable or not self.name:
            return signal
            
        try:
            from apps.risk_management.kelly_criterion import KellyCriterionEngine
            mode = self.config.get("kelly_mode", "half")
            engine = KellyCriterionEngine(mode=mode)
            
            perf = engine.get_historical_performance(self.name, local_pnl_history)
            if perf:
                win_rate, avg_win, avg_loss = perf
                kelly_fraction = engine.calculate_fraction(win_rate, avg_win, avg_loss)
                
                if kelly_fraction > 0:
                    stop_loss_pct = Decimal(str(self.config.get("stop_loss_pct", 2.0)))
                    stop_distance = signal.price * stop_loss_pct / Decimal("100")
                    
                    if stop_distance > 0:
                        risk_amount = account_equity * Decimal(str(kelly_fraction))
                        shares = risk_amount / stop_distance
                        signal.quantity = max(Decimal("1"), shares.quantize(Decimal("1")))
                        signal.reason += f" | Kelly ({mode}): {kelly_fraction:.2%} risk = {signal.quantity} sh"
                else:
                    # Negative edge or zero Kelly -> Sit in cash
                    signal.quantity = Decimal("0")
                    signal.action = Signal.HOLD
                    signal.reason += " -> BLOCKED by Kelly Criterion (Negative Expected Value)"
            else:
                 signal.reason += " | Kelly Skipped (< 10 historical trades)"
                 
        except Exception as e:
            logger.error(f"Error applying Kelly sizing for {signal.ticker}: {e}")
            
        return signal

    def __repr__(self):
        return f"<{self.__class__.__name__} '{self.name}' v{self.version}>"
