"""
BaseStrategy â€” abstract strategy framework for all trading algorithms.

Every strategy inherits from BaseStrategy and implements:
  - generate_signal(): analyze data and return a buy/sell/hold signal
  - calculate_position_size(): determine order quantity
  - check_exit(): evaluate whether to close an existing position

Per SCALABLE_BUILD_PLAN.md Layer 2: standard interface, auto-logging,
performance tracking (Sharpe ratio, win rate, max drawdown).
"""

import logging
from abc import ABC, abstractmethod
from datetime import datetime
from decimal import Decimal
from typing import Optional

from apps.market_data.models import OHLCVBar

logger = logging.getLogger(__name__)


class Signal:
    """Represents a trading signal generated by a strategy."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"

    def __init__(
        self,
        action: str,
        ticker: str,
        quantity: Decimal = Decimal("0"),
        price: Decimal = Decimal("0"),
        confidence: float = 0.0,
        reason: str = "",
        strategy_name: str = "",
    ):
        self.action = action
        self.ticker = ticker
        self.quantity = quantity
        self.price = price
        self.confidence = confidence
        self.reason = reason
        self.strategy_name = strategy_name
        self.timestamp = datetime.now()

    @property
    def is_actionable(self) -> bool:
        """True if this signal should trigger a trade (not HOLD)."""
        return self.action in (self.BUY, self.SELL)

    def to_dict(self) -> dict:
        """Convert to executor-compatible signal dict."""
        return {
            "ticker": self.ticker,
            "action": self.action,
            "quantity": str(self.quantity),
            "price": str(self.price),
            "strategy": self.strategy_name,
            "confidence": self.confidence,
            "reason": self.reason,
            "timestamp": self.timestamp.isoformat(),
        }

    def __repr__(self):
        return f"Signal({self.action} {self.quantity} {self.ticker} @ {self.price} | {self.reason})"


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Subclasses must implement:
      - generate_signal(ticker, bars) -> Signal
      - calculate_position_size(ticker, price, account_equity) -> Decimal
      - check_exit(ticker, entry_price, current_price, bars) -> Signal

    The strategy runner calls these methods for each active strategy.
    """

    name: str = "unnamed_strategy"
    version: str = "0.1.0"
    asset_class: str = "stocks"
    timeframe: str = "1d"
    description: str = ""

    def __init__(self, config: dict = None):
        """
        Initialize with optional config dict.

        Args:
            config: Strategy-specific parameters (from Strategy.custom_params).
        """
        self.config = config or {}

    @abstractmethod
    def generate_signal(self, ticker: str, bars: list) -> Signal:
        """
        Analyze market data and return a trading signal.

        Args:
            ticker: Stock symbol (e.g., "AAPL").
            bars: List of OHLCVBar-like dicts with keys:
                  open, high, low, close, volume, timestamp.

        Returns:
            Signal object (BUY, SELL, or HOLD).
        """
        pass

    @abstractmethod
    def calculate_position_size(
        self, ticker: str, price: Decimal, account_equity: Decimal
    ) -> Decimal:
        """
        Calculate the number of shares to buy/sell.

        Args:
            ticker: Stock symbol.
            price: Current/signal price.
            account_equity: Available account equity.

        Returns:
            Number of shares (Decimal).
        """
        pass

    @abstractmethod
    def check_exit(
        self, ticker: str, entry_price: Decimal, current_price: Decimal, bars: list
    ) -> Signal:
        """
        Check if an existing position should be closed.

        Args:
            ticker: Stock symbol.
            entry_price: Position entry price.
            current_price: Current market price.
            bars: Recent OHLCV data.

        Returns:
            Signal.SELL if should exit, Signal.HOLD if should keep.
        """
        pass

    def get_bars(self, ticker: str, timeframe: str = None, limit: int = 100) -> list:
        """
        Fetch OHLCV bars from the database.

        Returns list of dicts for easy indicator calculation.
        """
        tf = timeframe or self.timeframe
        bars = OHLCVBar.objects.filter(
            symbol=ticker, timeframe=tf
        ).order_by("-timestamp")[:limit]

        return [
            {
                "open": float(bar.open),
                "high": float(bar.high),
                "low": float(bar.low),
                "close": float(bar.close),
                "volume": bar.volume,
                "timestamp": bar.timestamp,
            }
            for bar in reversed(bars)  # Oldest first
        ]

    def __repr__(self):
        return f"<{self.__class__.__name__} '{self.name}' v{self.version}>"
